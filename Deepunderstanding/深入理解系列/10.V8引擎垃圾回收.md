# V8 引擎垃圾回收

## 为何需要垃圾回收

- 在 V8 引擎逐行执行 JavaScript 代码的过程中，当遇到函数的情况时，会为其创建一个函数执行上下文(Context)环境并添加到调用堆栈的栈顶，
- 函数的作用域(handleScope)中包含了该函数中声明的所有变量，
- 当该函数执行完毕后，对应的执行上下文从栈顶弹出，函数的作用域会随之销毁，其包含的所有变量也会统一释放并被自动回收。
- 试想如果在这个作用域被销毁的过程中，其中的变量不被回收，即持久占用内存，那么必然会导致内存暴增，
- 从而引发内存泄漏导致程序的性能直线下降甚至崩溃，因此内存在使用完毕之后理当归还给操作系统以保证内存的重复利用

## V8 引擎的内存限制

- V8 引擎在 64 位系统下最多只能使用约 1.4GB 的内存，在 32 位系统下最多只能使用约 0.7GB 的内存

- `那么为什么会有这种限制？`
  1. `JS 单线程机制：`垃圾回收的过程阻碍了主线程逻辑的执行，V8 执行垃圾回收时，程序中的其他各种逻辑都要进入暂停等待阶段
  2. `垃圾回收机制耗时：`假设 V8 的堆内存为 1.5G，那么 V8 做一次小的垃圾回收需要 50ms 以上，而做一次非增量式回收甚至需要 1s 以上，而在这 1s 的时间内，浏览器一直处于等待的状态，同时会失去对用户的响应

> 基于以上两点，V8 引擎为了减少对应用的性能造成的影响，采用了一种比较粗暴的手段，那就是直接限制堆内存的大小，毕竟在浏览器端一般也不会遇到需要操作几个 G 内存这样的场景

## V8 的垃圾回收策略

### V8 的内存结构

| 内存区域                     | 描述                                                                                                                                                                                                                                               |
| ---------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 新生代(new_space)            | 大多数的对象开始都会被分配在这里，该区域相对较小但是垃圾回收特别频繁。该区域被分为两半，一半用来分配内存，另一半用于在垃圾回收时将需要保留的对象复制过来。                                                                                         |
| 老生代(old_space)            | 新生代中的对象在存活一段时间后就会被转移到老生代内存区，相对于新生代该内存区域的垃圾回收频率较低。老生代又分为老生代指针区和老生代数据区，前者包含大多数可能存在指向其他对象的指针的对象，后者只保存原始数据对象，这些对象没有指向其他对象的指针。 |
| 大对象区(large_object_space) | 存放体积超越其他区域大小的对象，每个对象都会有自己的内存，垃圾回收不会移动大对象区。                                                                                                                                                               |
| 代码区(code_space)           | 代码对象会被分配在这里，是唯一拥有执行权限的内存区域。                                                                                                                                                                                             |
| map 区(map_space)            | 存放 Cell 和 Map，每个区域都是存放相同大小的元素，结构简单。                                                                                                                                                                                       |

![v8gc](./imgs/v8gc.png)

## 新生代 垃圾回收

- 主要采用了 Scavenge 算法。

- 在 Scavenge 算法的具体实现中，主要采用了 Cheney 算法，
- 它将新生代内存一分为二，每一个部分的空间称为 semispace，也就是我们在上图中看见的 new_space 中划分的两个区域，
- 其中处于激活状态的区域我们称为 From 空间，未激活(inactive new space)的区域我们称为 To 空间。
- 这两个空间中，始终只有一个处于使用状态，另一个处于闲置状态。
- 我们的程序中声明的对象首先会被分配到 From 空间，当进行垃圾回收时，
- 如果 From 空间中尚有存活对象，则会被复制到 To 空间进行保存，非存活的对象会被自动回收。
- 当复制完成后，From 空间和 To 空间完成一次角色互换，To 空间会变为新的 From 空间，原来的 From 空间则变为 To 空间。

### 流程图

- 假设在老生代中有 A、B、C、D 四个对象
- ![Alt text](./imgs/gc_porcess0.png)

- 在垃圾回收的标记阶段，将对象 A 和对象 C 标记为活动的
- ![Alt text](./imgs/gc_porcess1.png)

- 在垃圾回收的整理阶段，将活动的对象往堆内存的一端移动
- ![Alt text](./imgs/gc_porcess2.png)

- 在垃圾回收的清除阶段，将活动对象左侧的内存全部回收
- ![Alt text](./imgs/gc_porcess3.png)

## 参考文献

- https://juejin.cn/post/6844904016325902344
