import{_ as s,o as a,c as n,Q as l}from"./chunks/framework.ef8e9df1.js";const e="/verce-blog/assets/hoisted.d245ddef.jpg",h=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"home/vue3源码解读/index.md","filePath":"home/vue3源码解读/index.md","lastUpdated":1700472544000}'),t={name:"home/vue3源码解读/index.md"},p=l(`<h2 id="vue3-概览" tabindex="-1">Vue3 概览 <a class="header-anchor" href="#vue3-概览" aria-label="Permalink to &quot;Vue3 概览&quot;">​</a></h2><blockquote><p>目录说明</p></blockquote><table><thead><tr><th>包名</th><th>描述</th></tr></thead><tbody><tr><td>@vue/shared</td><td>包含通用的工具函数和常量，是其他包的依赖项</td></tr><tr><td>@vue/reactivity</td><td>实现了 Vue.js 的响应式系统，包括依赖追踪和触发更新等功能</td></tr><tr><td>@vue/compiler-core</td><td>Vue.js 编译器的核心包，将模板编译为渲染函数</td></tr><tr><td>@vue/runtime-core</td><td>Vue.js 运行时的核心包，提供组件实例化和虚拟 DOM 渲染等功能</td></tr><tr><td>@vue/runtime-dom</td><td>Vue.js 运行时的 DOM 版本包，提供在浏览器环境下运行 Vue.js 的功能</td></tr><tr><td>@vue/compiler-dom</td><td>Vue.js 编译器的 DOM 版本包，将模板编译为浏览器可执行的渲染函数</td></tr><tr><td>@vue/server-renderer</td><td>Vue.js 服务器端渲染（SSR）的渲染器包，用于在服务器端渲染 Vue.js 应用</td></tr><tr><td>@vue/compiler-ssr</td><td>Vue.js 编译器的服务器端渲染（SSR）版本包，将模板编译为服务器端可执行的渲染函数</td></tr><tr><td>@vue/test-utils</td><td>Vue.js 的测试工具包，用于编写和运行单元测试和集成测试</td></tr><tr><td>@vue/use</td><td>Vue.js 的 Composition API 的实现包，用于支持组合式开发</td></tr></tbody></table><blockquote><p>响应式想要解决的问题</p></blockquote><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> a </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> b </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;"> a;</span></span>
<span class="line"><span style="color:#6A737D;">// 要始终保持b是a的2倍，需要 指令式 的调用方法</span></span>
<span class="line"><span style="color:#E1E4E8;">a </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">3</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">b </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;"> a;</span></span>
<span class="line"><span style="color:#6A737D;">// 响应式想要解决的是类似 fx = A * 2 这类有明确关系的中间处理函数的维护成本；保证A和B的同步</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">let</span><span style="color:#24292E;"> a </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#D73A49;">let</span><span style="color:#24292E;"> b </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">2</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">*</span><span style="color:#24292E;"> a;</span></span>
<span class="line"><span style="color:#6A737D;">// 要始终保持b是a的2倍，需要 指令式 的调用方法</span></span>
<span class="line"><span style="color:#24292E;">a </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">3</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">b </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">2</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">*</span><span style="color:#24292E;"> a;</span></span>
<span class="line"><span style="color:#6A737D;">// 响应式想要解决的是类似 fx = A * 2 这类有明确关系的中间处理函数的维护成本；保证A和B的同步</span></span></code></pre></div><div class="language-vue vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">&lt;!-- 衍生：加入state的a属性修改，界面dom要显示 出来；</span></span>
<span class="line"><span style="color:#6A737D;"> 维护的是状态和dom输出之间的逻辑（声明式渲染） --&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#85E89D;">span</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">{{state.a * 10}}</span></span>
<span class="line"><span style="color:#E1E4E8;">&lt;/</span><span style="color:#85E89D;">span</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">onStateChanged (()=&gt;{ view = render(state) })</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">&lt;!-- 衍生：加入state的a属性修改，界面dom要显示 出来；</span></span>
<span class="line"><span style="color:#6A737D;"> 维护的是状态和dom输出之间的逻辑（声明式渲染） --&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">&lt;</span><span style="color:#22863A;">span</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">{{state.a * 10}}</span></span>
<span class="line"><span style="color:#24292E;">&lt;/</span><span style="color:#22863A;">span</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">onStateChanged (()=&gt;{ view = render(state) })</span></span></code></pre></div><ul><li>vue 实现了追踪变量的依赖（称之为追踪器），然后执行对应的“副作用”逻辑</li></ul><h2 id="vue2-和-vue3-的不同" tabindex="-1">vue2 和 vue3 的不同 <a class="header-anchor" href="#vue2-和-vue3-的不同" aria-label="Permalink to &quot;vue2 和 vue3 的不同&quot;">​</a></h2><ol><li>双向数据绑定原理不同</li><li>是否支持碎片 <ol><li>vue2：vue2 不支持碎片。</li><li>vue3：vue3 支持碎片（Fragments） ，就是说可以拥有多个根节点。</li></ol></li><li>API 类型不同 <ol><li>vue2：vue2 使用选项类型 api，选项型 api 在代码里分割了不同的属性：data,computed,methods 等</li><li>vue3：vue3 使用 Composition API ，相比于旧的 api 使用属性来分组，这样代码会更加简便和整洁</li></ol></li><li>定义数据变量和方法不同 <ol><li>vue2：vue2 是把数据放入 data 中，在 vue2 中定义数据变量是 data(){} ，创建的方法要在 methods:{} 中</li><li>vue3：vue3 就需要使用一个新的 setup()方法，此方法在组件初始化构造的时候触发</li></ol></li><li>生命周期的变化</li></ol><blockquote><p>PatchFlag 带来的性能提升</p></blockquote><ul><li>Vue 2.x 中的虚拟 DOM 是全量对比的模式，而到了 Vue 3.0 开始，新增了静态标记（PatchFlag）</li><li>Vue3 在模板编译阶段 用 hoisted、openBlock 进行 静态提升；由 Vue2 的 vdom 全量对比改成只对比修改过的 dom</li><li><img src="`+e+'" alt="hoisted、openBlock"></li></ul>',11),o=[p];function c(r,i,d,u,E,y){return a(),n("div",null,o)}const m=s(t,[["render",c]]);export{h as __pageData,m as default};
