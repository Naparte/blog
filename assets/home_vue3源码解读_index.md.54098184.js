import{_ as s,o as a,c as n,Q as l}from"./chunks/framework.ef8e9df1.js";const v=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"home/vue3源码解读/index.md","filePath":"home/vue3源码解读/index.md","lastUpdated":1700472544000}'),p={name:"home/vue3源码解读/index.md"},t=l(`<h2 id="vue3-概览" tabindex="-1">Vue3 概览 <a class="header-anchor" href="#vue3-概览" aria-label="Permalink to &quot;Vue3 概览&quot;">​</a></h2><blockquote><p>目录说明</p></blockquote><table><thead><tr><th>包名</th><th>描述</th></tr></thead><tbody><tr><td>@vue/shared</td><td>包含通用的工具函数和常量，是其他包的依赖项</td></tr><tr><td>@vue/reactivity</td><td>实现了 Vue.js 的响应式系统，包括依赖追踪和触发更新等功能</td></tr><tr><td>@vue/compiler-core</td><td>Vue.js 编译器的核心包，将模板编译为渲染函数</td></tr><tr><td>@vue/runtime-core</td><td>Vue.js 运行时的核心包，提供组件实例化和虚拟 DOM 渲染等功能</td></tr><tr><td>@vue/runtime-dom</td><td>Vue.js 运行时的 DOM 版本包，提供在浏览器环境下运行 Vue.js 的功能</td></tr><tr><td>@vue/compiler-dom</td><td>Vue.js 编译器的 DOM 版本包，将模板编译为浏览器可执行的渲染函数</td></tr><tr><td>@vue/server-renderer</td><td>Vue.js 服务器端渲染（SSR）的渲染器包，用于在服务器端渲染 Vue.js 应用</td></tr><tr><td>@vue/compiler-ssr</td><td>Vue.js 编译器的服务器端渲染（SSR）版本包，将模板编译为服务器端可执行的渲染函数</td></tr><tr><td>@vue/test-utils</td><td>Vue.js 的测试工具包，用于编写和运行单元测试和集成测试</td></tr><tr><td>@vue/use</td><td>Vue.js 的 Composition API 的实现包，用于支持组合式开发</td></tr></tbody></table><blockquote><p>响应式想要解决的问题</p></blockquote><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> a </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> b </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;"> a;</span></span>
<span class="line"><span style="color:#6A737D;">// 要始终保持b是a的2倍，需要 指令式 的调用方法</span></span>
<span class="line"><span style="color:#E1E4E8;">a </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">3</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">b </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;"> a;</span></span>
<span class="line"><span style="color:#6A737D;">// 响应式想要解决的是类似 fx = A * 2 这类有明确关系的中间处理函数的维护成本；保证A和B的同步</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">let</span><span style="color:#24292E;"> a </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#D73A49;">let</span><span style="color:#24292E;"> b </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">2</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">*</span><span style="color:#24292E;"> a;</span></span>
<span class="line"><span style="color:#6A737D;">// 要始终保持b是a的2倍，需要 指令式 的调用方法</span></span>
<span class="line"><span style="color:#24292E;">a </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">3</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">b </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">2</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">*</span><span style="color:#24292E;"> a;</span></span>
<span class="line"><span style="color:#6A737D;">// 响应式想要解决的是类似 fx = A * 2 这类有明确关系的中间处理函数的维护成本；保证A和B的同步</span></span></code></pre></div><div class="language-vue vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">&lt;!-- 衍生：加入state的a属性修改，界面dom要显示 出来；</span></span>
<span class="line"><span style="color:#6A737D;"> 维护的是状态和dom输出之间的逻辑（声明式渲染） --&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#85E89D;">span</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">{{state.a * 10}}</span></span>
<span class="line"><span style="color:#E1E4E8;">&lt;/</span><span style="color:#85E89D;">span</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">onStateChanged (()=&gt;{ view = render(state) })</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">&lt;!-- 衍生：加入state的a属性修改，界面dom要显示 出来；</span></span>
<span class="line"><span style="color:#6A737D;"> 维护的是状态和dom输出之间的逻辑（声明式渲染） --&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">&lt;</span><span style="color:#22863A;">span</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">{{state.a * 10}}</span></span>
<span class="line"><span style="color:#24292E;">&lt;/</span><span style="color:#22863A;">span</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">onStateChanged (()=&gt;{ view = render(state) })</span></span></code></pre></div><ul><li>vue 实现了追踪变量的依赖（称之为追踪器），然后执行对应的“副作用”逻辑</li></ul>`,7),e=[t];function o(c,r,d,i,E,y){return a(),n("div",null,e)}const h=s(p,[["render",o]]);export{v as __pageData,h as default};
